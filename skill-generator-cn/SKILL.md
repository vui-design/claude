---
name: skill-generator-cn
description: 当用户想要"创建技能"、"创建新技能"、"更新现有技能"、"改进技能"、"构建技能"、"设计技能"，或需要有关技能结构、渐进式披露、验证或技能开发最佳实践的指导时，无论是独立技能还是Claude Code插件技能，都应使用此技能。
---

# Claude Code Skill 生成器

该技能提供全面的指导，用于创建有效的技能，通过专业知识、工作流程和工具集成来扩展Claude的能力。

## 关于技能

技能是模块化的、独立的包，通过提供专业知识、工作流程和工具来扩展Claude的能力。可以将它们视为特定领域或任务的"入职指南"——它们将Claude从一个通用代理转变为一个配备了模型无法完全掌握的程序性知识的专业代理。

### 技能提供的内容

1. **专业工作流程** - 针对特定领域的多步骤程序
2. **工具集成** - 处理特定文件格式或API的指令
3. **领域专业知识** - 公司特定的知识、模式、业务逻辑
4. **捆绑资源** - 用于复杂和重复任务的脚本、参考资料和资产

## 核心原则

### 简洁是关键

上下文窗口是公共资源。技能与Claude需要的其他所有内容共享上下文窗口：系统提示、对话历史、其他技能的元数据以及实际的用户请求。

**默认假设：Claude已经非常聪明。** 只添加Claude尚未拥有的上下文。质疑每条信息："Claude真的需要这个解释吗？"以及"这段内容是否配得上它的Token成本？"

优先使用简洁的示例而非冗长的解释。

### 设置适当的自由度

将具体程度与任务的脆弱性和可变性相匹配：

**高自由度（基于文本的指令）**：当存在多种有效方法、决策取决于上下文或启发式方法指导操作时使用。

**中等自由度（带参数的伪代码或脚本）**：当存在首选模式、允许一定变化或配置影响行为时使用。

**低自由度（特定脚本、少量参数）**：当操作脆弱且容易出错、一致性至关重要或必须遵循特定序列时使用。

可以将Claude想象成探索一条路径：两侧有悬崖的狭窄桥梁需要特定的护栏（低自由度），而开阔的田野允许多条路线（高自由度）。

## 技能剖析

每个技能由一个必需的SKILL.md文件和可选的捆绑资源组成：

```
skill-name/
├── SKILL.md（必需）
│   ├── YAML前置元数据（必需）
│   │   ├── name:（必需）
│   │   ├── description:（必需）
│   │   └── version:（可选，插件推荐）
│   └── Markdown说明（必需）
└── 捆绑资源（可选）
    ├── scripts/          - 可执行代码（Python/Bash/等）
    ├── references/       - 按需加载到上下文中的文档
    └── assets/           - 用于输出的文件（模板、图标、字体等）
```

### SKILL.md（必需）

每个SKILL.md包含：

- **前置元数据**（YAML）：包含`name`和`description`字段。这些是Claude用来确定何时使用技能的唯一字段，因此清晰全面地描述技能是什么以及何时应该使用它非常重要。
  - **name**：连字符格式的标识符（例如`data-analyzer`），仅小写字母、数字和连字符，最多64个字符
  - **description**：使用第三人称格式（例如"当用户...时应使用此技能"）并包含用户会说的特定触发短语。包含应触发此技能的具体场景。最多1024个字符。
  - **version**：（可选）用于跟踪更改的语义版本号（插件技能推荐）

- **正文**（Markdown）：使用技能及其捆绑资源的说明和指导。仅在技能触发后加载（如果需要）。使用祈使句/不定式形式（动词优先的指令）编写，而不是第二人称。

### 捆绑资源（可选）

#### 脚本（`scripts/`）

需要确定性可靠性或重复编写的任务的可执行代码（Python/Bash/等）。

- **何时包含**：当相同的代码被重复编写或需要确定性可靠性时
- **示例**：用于PDF旋转任务的`scripts/rotate_pdf.py`
- **优势**：Token高效、确定性、可能无需加载到上下文中即可执行
- **注意**：脚本可能仍需要被Claude读取以进行修补或环境特定调整

#### 参考资料（`references/`）

按需加载到上下文中以指导Claude的流程和思考的文档和参考资料。

- **何时包含**：用于Claude在工作时应参考的文档
- **示例**：用于财务模式的`references/finance.md`，用于公司NDA模板的`references/mnda.md`，用于公司政策的`references/policies.md`，用于API规范的`references/api.md`
- **用例**：数据库模式、API文档、领域知识、公司政策、详细的工作流程指南
- **优势**：保持SKILL.md精简，仅在Claude确定需要时才加载
- **最佳实践**：如果文件很大（>10k），在SKILL.md中包含grep搜索模式
- **避免重复**：信息应只存在于SKILL.md或参考资料中，而不是两者都有。除非确实是技能的核心，否则优先使用参考资料存储详细信息——这样可以保持SKILL.md精简，同时使信息可被发现而不占用上下文窗口。

#### 资产（`assets/`）

不打算加载到上下文中，而是在Claude产生的输出中使用的文件。

- **何时包含**：当技能需要在最终输出中使用的文件时
- **示例**：用于品牌资产的`assets/logo.png`，用于PowerPoint模板的`assets/slides.pptx`，用于HTML/React样板的`assets/frontend-template/`，用于字体的`assets/font.ttf`
- **用例**：模板、图像、图标、样板代码、字体、被复制或修改的示例文档
- **优势**：将输出资源与文档分离，使Claude能够使用文件而无需将其加载到上下文中

#### 不应包含在技能中的内容

技能应仅包含直接支持其功能的基本文件，请勿创建无关的文档或辅助文件，包括：

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md
- 等等

技能应仅包含AI代理完成手头工作所需的信息。它不应包含关于创建过程的辅助上下文、设置和测试程序、面向用户的文档等。创建额外的文档文件只会增加混乱和困惑。

### 渐进式披露设计原则

技能使用三级加载系统来高效管理上下文：

1. **元数据（name + description）** - 始终在上下文中（约100字）
2. **SKILL.md正文** - 技能触发时（<5k，理想情况下为1,500-2,000字）
3. **捆绑资源** - 根据Claude需要加载（无限制，因为脚本无需读入上下文窗口即可执行）

#### 渐进式披露模式

保持SKILL.md正文精简，少于500行，以减少上下文冗余。接近此限制时，请将内容拆分为单独的文件。在将内容拆分到其他文件时，务必在SKILL.md中引用这些文件，并明确说明何时读取它们，以确保技能文档的读者知道这些文件的存在以及何时使用它们。

**关键原则：** 当技能支持多个变体、框架或选项时，仅在SKILL.md中保留核心工作流程和选择指导。将变体特定的详细信息（模式、示例、配置）移动到单独的参考资料中。

**模式1：带参考资料的高级指南**

```markdown
# PDF处理

## 快速入门

使用pdfplumber提取文本：
[代码示例]

## 高级功能

- **表单填充**：参见references/forms.md获取完整指南
- **API参考**：参见references/api-reference.md获取所有方法
- **示例**：参见references/examples.md获取常见模式
```

Claude仅在需要时加载forms.md、api-reference.md或examples.md。

**模式2：按领域组织**

对于具有多个领域的技能，按领域组织内容以避免加载无关上下文：

```
bigquery-skill/
├── SKILL.md（概述和导航）
└── references/
    ├── finance.md（收入、计费指标）
    ├── sales.md（机会、管道）
    ├── product.md（API使用、功能）
    └── marketing.md（活动、归因）
```

当用户询问销售指标时，Claude仅读取sales.md。

类似地，对于支持多个框架或变体的技能，按变体组织：

```
cloud-deploy/
├── SKILL.md（工作流程 + 提供商选择）
└── references/
    ├── aws.md（AWS部署模式）
    ├── gcp.md（GCP部署模式）
    └── azure.md（Azure部署模式）
```

当用户选择AWS时，Claude仅读取aws.md。

**模式3：条件详细信息**

显示基本内容，链接到高级内容：

```markdown
# DOCX处理

## 创建文档

使用docx-js创建新文档。参见references/docx-js.md。

## 编辑文档

对于简单编辑，直接修改XML。

**对于跟踪更改**：参见references/redlining.md
**对于OOXML详细信息**：参见references/ooxml.md
```

Claude仅在用户需要这些功能时读取redlining.md或ooxml.md。

**重要指南：**

- **避免深度嵌套的引用** - 保持引用从SKILL.md开始仅一层深度，所有引用文件都应直接从SKILL.md链接。
- **构建较长的引用文件** - 对于超过100行的文件，在顶部包含目录，以便Claude在预览时可以看到完整范围。

## 技能创建流程

技能创建包括以下步骤：

1. 通过具体示例理解技能
2. 规划可重用的技能内容（脚本、参考资料、资产）
3. 初始化技能（对于独立技能运行`init.py`，或为插件技能创建目录结构）
4. 编辑技能（实现资源并编写SKILL.md）
5. 验证技能（运行`validate.py`）
6. 打包技能（对于独立技能运行`package.py`；对于插件技能跳过）
7. 根据实际使用情况迭代

创建技能时，请按顺序遵循"技能创建流程"，仅在有明确理由说明它们不适用时才跳过步骤。

### 步骤1：通过具体示例理解技能

仅在技能的使用模式已经清楚理解时才跳过此步骤。即使在处理现有技能时，它仍然很有价值。

要创建一个有效的技能，需要清晰地理解如何使用技能的具体示例。这种理解可以来自直接的用户示例，也可以来自经过用户反馈验证的生成示例。

例如，在构建图像编辑器技能时，相关问题包括：

- "图像编辑器技能应该支持哪些功能？编辑、旋转，还有其他吗？"
- "你能否提供一些如何使用此技能的示例吗？"
- "我可以想象用户会提出诸如'从此图像中去除红眼'或'旋转此图像'之类的要求，你认为这个技能还会有哪些使用方式？"
- "用户说什么应该触发此技能？"

为避免让用户感到不知所措，避免在单条消息中提出过多问题。从最重要的问题开始，并根据需要跟进以获得更好的效果。

当对技能应支持的功能有清晰的认识时，结束此步骤。

### 步骤2：规划可重用的技能内容

为了将具体示例转化为有效的技能，通过以下方式分析每个示例：

1. 考虑如何从头开始执行示例
2. 确定在重复执行这些工作流程时，哪些脚本、参考资料和资产会有帮助

示例：在构建`pdf-editor`技能以处理"帮我旋转此PDF"这类查询时，分析显示：

1. 旋转PDF每次都需要重新编写相同的代码
2. 在技能中存储`scripts/rotate_pdf.py`脚本会很有帮助

示例：在设计`frontend-webapp-builder`技能以处理"为我构建一个待办事项应用"或"为我构建一个仪表盘来跟踪我的步数"这类查询时，分析显示：

1. 编写前端Web应用每次都需要相同的HTML/React样板
2. 在技能中存储包含HTML/React项目样板文件的`assets/hello-world/`模板会很有帮助

示例：在构建`big-query`技能以处理"今天有多少用户登录？"这类查询时，分析显示：

1. 查询BigQuery每次都需要重新发现表模式和关系
2. 在技能中存储记录表模式的`references/schema.md`文件会很有帮助

**对于Claude Code插件：** 在构建钩子技能时，分析显示：
1. 开发者需要反复验证hooks.json并测试钩子脚本
2. 在技能中存储`scripts/validate-hook-schema.sh`和`scripts/test-hook.sh`实用程序会很有帮助
3. `references/patterns.md`用于详细的钩子模式以避免使SKILL.md膨胀

为了建立技能的内容，分析每个具体示例，创建要包含的可重用资源列表：脚本、参考资料和资产。

### 步骤3：初始化技能

此时，是时候实际创建技能了。

仅当正在开发的技能已经存在，并且需要迭代或打包时才跳过此步骤。在这种情况下，继续下一步。

#### 对于独立技能

从头开始创建新的独立技能时，始终运行`init.py`脚本。该脚本方便地生成一个新的模板技能目录，自动包含技能所需的一切，使技能创建过程更加高效可靠。

用法：

```bash
scripts/init.py <skill-name> --path <output-directory>
```

该脚本：

- 在指定路径创建技能目录
- 生成带有正确前置元数据和TODO占位符的SKILL.md模板
- 创建示例资源目录：`scripts/`、`references/`和`assets/`
- 在每个目录中添加可自定义或删除的示例文件

初始化后，根据需要自定义或删除生成的SKILL.md和示例文件。

#### 对于Claude Code插件技能

对于插件技能，手动创建技能目录结构：

```bash
mkdir -p plugin-name/skills/skill-name/{references,scripts,assets}
touch plugin-name/skills/skill-name/SKILL.md
```

注意，与使用`init.py`脚本创建独立技能不同，插件技能直接在插件的`skills/`目录中创建，使用更简单的手动操作，由Claude Code自动发现。

### 步骤4：编辑技能

在编辑（新生成的或现有的）技能时，请记住该技能是为另一个Claude实例使用而创建的。包含对Claude有益且不明显的信息。考虑哪些程序性知识、领域特定的详细信息或可重用资产可以帮助另一个Claude实例更有效地执行这些任务。

#### 学习经过验证的设计模式

根据技能的需求查阅这些有用的指南：

- **多步骤流程**：参见`references/workflows.md`了解顺序工作流程和条件逻辑
- **特定输出格式或质量标准**：参见`references/output-patterns.md`了解模板和示例模式

这些文件包含有效技能设计的既定最佳实践。

#### 从可重用的技能内容开始

要开始实现，从上面确定的可重用资源开始：`scripts/`、`references/`和`assets/`文件。请注意，此步骤可能需要用户输入。例如，在实现`brand-guidelines`技能时，用户可能需要提供要存储在`assets/`中的品牌资产或模板，或要存储在`references/`中的文档。

添加的脚本必须通过实际运行来测试，以确保没有错误且输出符合预期。如果有很多类似的脚本，只需要测试一个有代表性的样本，以确保它们都能正常工作，同时平衡完成时间。

应删除技能不需要的任何示例文件和目录。初始化脚本在`scripts/`、`references/`和`assets/`中创建示例文件以演示结构，但大多数技能不需要这些文件。

#### 更新SKILL.md

**写作风格：** 使用**祈使句/不定式形式**（动词优先的指令）编写整个技能，而不是以第二人称进行描述。使用客观的指导性语言（例如"要完成X，执行Y"而不是"您应该执行X"或"如果您需要执行X"）。这有助于保持一致性，并使人工智能（AI）的使用更加清晰。

##### 前置元数据

使用`name`、`description`和可选的`version`编写YAML前置元数据：

- `name`：连字符格式的技能名称
- `description`：这是技能的主要触发机制，帮助Claude理解何时使用该技能。**关键要求：**
  - **使用第三人称**："当用户...时应使用此技能"（不是"当...时使用此技能"）
  - **包含特定的触发短语**：包含用户会说的实际短语（"创建钩子"、"添加身份验证"、"配置设置"）
  - **列出具体场景**：明确触发此技能的内容
  - **不要模糊或笼统**：避免没有触发器的"为X提供指导"之类的描述
  - 示例："当用户要求'创建钩子'、'添加PreToolUse钩子'、'验证工具使用'或提及钩子事件（PreToolUse、PostToolUse、Stop）时，应使用此技能。"
- `version`：（可选）语义版本号（插件技能推荐）

除了这些和允许的字段（license、allowed-tools、metadata）之外，不要在YAML前置元数据中包含任何其他字段。

##### 正文

编写使用技能及其捆绑资源的说明。

**目标长度：** 正文1,500-2,000字，保持在最多3,000字以下；将详细内容移至references/。

**内容组织：**
1. 技能的目的（几句话）
2. 核心概念和概述
3. 基本程序和工作流程
4. 快速参考表（如适用）
5. 指向references/examples/scripts的指针，并清楚说明何时使用它们
6. 最常见的用例

**移至references/的内容：**
- 详细的模式和高级技术
- 全面的API文档
- 迁移指南
- 边缘情况和故障排除
- 大量示例和演练

**清楚地引用资源：**
```markdown
## 其他资源

### 参考文件

有关详细模式和技术，请查阅：
- **`references/patterns.md`** - 常见设计模式
- **`references/advanced.md`** - 高级用例和边缘情况

### 示例文件

`examples/`中的工作示例：
- **`examples/basic-example.sh`** - 基本使用示例
```

### 步骤5：验证技能

在打包或部署之前，验证技能以确保其满足所有要求。

#### 对于独立技能

使用验证脚本：

```bash
scripts/validate.py path/to/skill-folder
```

验证器检查：
- YAML前置元数据格式和必需字段
- 技能命名约定（连字符格式、长度限制）
- 描述质量和长度限制
- 文件结构

#### 对于插件技能

对于插件技能，验证方式与独立技能不同：

1. **检查结构**：技能目录位于`plugin-name/skills/skill-name/`中
2. **验证SKILL.md**：具有`name`和`description`的前置元数据
3. **检查触发短语**：描述包含第三人称的特定用户查询
4. **验证写作风格**：正文使用祈使句/不定式形式，而不是以第二人称进行描述
5. **测试渐进式披露**：SKILL.md精简（约1,500-2,000字），详细内容在references/中
6. **检查引用**：所有引用的文件都存在
7. **验证示例**：示例完整且正确
8. **测试脚本**：脚本可执行且正常工作

测试技能：

```bash
# 使用插件目录测试
cc --plugin-dir /path/to/plugin

# 提出应该触发技能的问题
# 验证技能正确加载
```

#### 验证检查清单

在最终确定技能之前：

**结构：**
- [ ] SKILL.md文件存在且具有有效的YAML前置元数据
- [ ] 前置元数据具有name和description字段
- [ ] 名称遵循连字符格式约定（最多64个字符）
- [ ] 描述少于1024个字符
- [ ] Markdown正文存在且内容充实
- [ ] 引用的文件实际存在

**描述质量：**
- [ ] 使用第三人称（"当用户...时应使用此技能"）
- [ ] 包含用户会说的特定触发短语
- [ ] 列出具体场景（"创建X"、"配置Y"）
- [ ] 不模糊或笼统

**内容质量：**
- [ ] SKILL.md正文使用祈使句/不定式形式
- [ ] 正文集中且精简（理想情况下1,500-2,000字，最多<5k）
- [ ] 详细内容移至references/
- [ ] 示例完整且可用
- [ ] 脚本可执行且正常工作

**渐进式披露：**
- [ ] SKILL.md中的核心概念
- [ ] references/中的详细文档
- [ ] examples/中的工作代码（如适用）
- [ ] scripts/中的实用程序（如适用）
- [ ] SKILL.md清楚地引用这些资源

**测试：**
- [ ] 技能在预期的用户查询上触发
- [ ] 内容对预期任务有帮助
- [ ] 文件之间没有重复信息
- [ ] 按需加载引用

### 步骤6：打包技能（仅限独立技能）

#### 对于独立技能

对于独立技能，开发完成后，将其打包为可分发的.skill文件：

```bash
scripts/package.py <path/to/skill-folder>
```

可选的输出目录规范：

```bash
scripts/package.py <path/to/skill-folder> ./dist
```

打包脚本将：

1. **验证**技能自动（与`validate.py`执行相同的检查）
2. **打包**技能（如果验证通过），创建以技能命名的.skill文件（zip格式）（例如`my-skill.skill`）

如果验证失败，脚本将报告错误并退出而不创建包；修复任何验证错误并再次运行打包命令。

#### 对于插件技能

对于插件技能，跳过此步骤。插件技能作为插件的一部分分发，而不是单独的包；用户在安装插件时自动获得技能。

### 步骤7：迭代

测试技能后，用户可能会要求改进。这通常在使用技能后立即发生，对技能表现有清晰认知。

**迭代工作流程：**

1. 在实际任务上使用技能
2. 注意困难或低效率
3. 确定应如何更新SKILL.md或捆绑资源
4. 实施更改并再次测试

**常见改进：**
- 加强描述中的触发短语
- 将SKILL.md中的长节移至references/
- 添加缺失的示例或脚本
- 澄清模糊的指令
- 添加边缘情况处理

## 插件特定说明

### 插件技能位置

插件技能位于插件的`skills/`目录中：

```
my-plugin/
├── .claude-plugin/
│   └── plugin.json
├── commands/
├── agents/
└── skills/
    └── my-skill/
        ├── SKILL.md
        ├── references/
        ├── scripts/
        └── assets/
```

### 自动发现

Claude Code自动发现技能：
- 扫描`skills/`目录
- 查找包含`SKILL.md`的子目录
- 始终加载技能元数据（name + description）
- 技能触发时加载SKILL.md正文
- 需要时加载references/examples

### 无需打包

插件技能作为插件的一部分分发，而不是单独的包；用户在安装插件时自动获得技能。

### 插件技能测试

通过本地安装插件来测试技能：

```bash
# 使用--plugin-dir测试
cc --plugin-dir /path/to/plugin

# 提出应该触发技能的问题
# 验证技能正确加载
```

## 写作风格要求

### 祈使句/不定式形式

使用祈使句/不定式形式（动词优先的指令），而不是以第二人称进行描述。

❌ **错误（第二人称）：**
```
您应该通过定义事件类型来创建钩子。
您需要配置MCP服务器。
您必须在使用前验证设置。
Claude应该解析前置元数据。
```

✅ **正确（祈使句）：**
```
要创建钩子，定义事件类型。
使用身份验证配置MCP服务器。
使用前验证设置。
使用sed解析前置元数据。
```

### 描述中的第三人称

前置元数据描述必须使用第三人称：

❌ **错误：**
```yaml
description: 当您想要创建X时使用此技能...
description: 当用户要求时加载此技能...
```

✅ **正确：**
```yaml
description: 当用户要求"创建X"、"配置Y"时应使用此技能...
```

### 客观的指导性语言

关注做什么，而不是谁应该做：

❌ **错误：**
```
您可以解析前置元数据...
用户可能会验证值...
```

✅ **正确：**
```
使用sed解析前置元数据。
使用grep提取字段。
使用前验证值。
```

## 常见错误示例

### 错误1：触发描述弱

❌ **错误：**
```yaml
description: 为使用钩子提供指导。
```

**为什么错误：** 模糊，没有特定的触发短语，也不是以第三人称进行说明

✅ **正确：**
```yaml
description: 当用户要求"创建钩子"、"添加PreToolUse钩子"、"验证工具使用"或提及钩子事件时，应使用此技能。提供全面的钩子API指导。
```

**为什么正确：** 以第三人称进行说明，特定短语，具体场景

### 错误2：SKILL.md中内容过多

❌ **错误：**
```
skill-name/
└── SKILL.md（8,000字，一个文件中的所有内容）
```

**为什么错误：** 技能加载时使上下文膨胀，详细内容始终加载

✅ **正确：**
```
skill-name/
├── SKILL.md（1,800字，核心要点）
└── references/
    ├── patterns.md（2,500字）
    └── advanced.md（3,700字）
```

**为什么正确：** 渐进式披露，仅在需要时加载详细内容

### 错误3：第二人称写作

❌ **错误：**
```markdown
您应该首先读取配置文件。
您需要验证输入。
您可以使用grep工具进行搜索。
```

**为什么错误：** 以第二人称进行说明，不是祈使句形式

✅ **正确：**
```markdown
首先读取配置文件。
处理前验证输入。
使用grep工具搜索模式。
```

**为什么正确：** 祈使句形式，直接指令

### 错误4：缺少资源引用

❌ **错误：**
```markdown
# SKILL.md

[核心内容]

[未提及references/或scripts/]
```

**为什么错误：** Claude不知道引用存在

✅ **正确：**
```markdown
# SKILL.md

[核心内容]

## 其他资源

### 参考文件
- **`references/patterns.md`** - 详细模式
- **`references/advanced.md`** - 高级技术

### 脚本
- **`scripts/validate.sh`** - 验证实用程序
```

**为什么正确：** Claude知道在哪里找到其他信息

## 最佳实践摘要

✅ **应该：**
- 在描述中使用第三人称（"当用户...时应使用此技能"）
- 包含特定的触发短语（"创建X"、"配置Y"）
- 保持SKILL.md精简（1,500-2,000字）
- 使用渐进式披露（将详细信息移至references/）
- 使用祈使句/不定式形式编写
- 清楚地引用支持文件
- 提供工作示例
- 为常见操作创建实用脚本
- 测试脚本以确保它们工作
- 打包前验证

❌ **不应该：**
- 在任何地方使用第二人称
- 使用模糊的触发条件
- 将所有内容放在SKILL.md中（没有references/的>3,000字）
- 使用第二人称编写（"您应该..."）
- 不引用资源
- 包含损坏或不完整的示例
- 跳过验证
- 创建无关的文档文件（README.md等）

## 快速参考

### 最小技能

```
skill-name/
└── SKILL.md
```

适用于：简单知识，不需要复杂资源

### 标准技能（推荐）

```
skill-name/
├── SKILL.md
├── references/
│   └── detailed-guide.md
└── scripts/
    └── helper-script.py
```

适用于：大多数具有详细文档和实用程序的技能

### 完整技能

```
skill-name/
├── SKILL.md
├── references/
│   ├── patterns.md
│   └── advanced.md
├── scripts/
│   └── validate.sh
└── assets/
    └── template.json
```

适用于：具有验证实用程序和模板的复杂领域

## 其他资源

### 参考文件

有关技能设计模式的详细指导：
- **`references/workflows.md`** - 顺序和条件工作流程模式
- **`references/output-patterns.md`** - 用于一致输出的模板和示例模式

### 脚本

技能开发的实用脚本：
- **`scripts/init.py`** - 从模板初始化新技能（独立技能）
- **`scripts/validate.py`** - 验证技能结构和内容
- **`scripts/package.py`** - 将技能打包为可分发的.skill文件（独立技能）

## 实现工作流程摘要

要创建技能：

1. **理解用例**：确定技能使用的具体示例
2. **规划资源**：确定需要哪些/referencesscripts/assets
3. **初始化结构**：
   - 独立：运行`scripts/init.py <skill-name> --path <path>`
   - 插件：`mkdir -p plugin/skills/skill-name/{references,scripts,assets}`
4. **编写SKILL.md**：
   - 带有第三人称描述和触发短语的前置元数据
   - 祈使句形式的精简正文（1,500-2,000字）
   - 引用支持文件
5. **添加资源**：根据需要创建references/、scripts/、assets/
6. **验证**：
   - 独立：运行`scripts/validate.py path/to/skill`
   - 插件：使用`cc --plugin-dir /path/to/plugin`测试
7. **打包**（仅限独立）：运行`scripts/package.py path/to/skill`
8. **迭代**：基于使用改进

专注于强大的触发描述、渐进式披露和祈使句写作风格，以创建在需要时加载并提供有针对性指导的有效技能。